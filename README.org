This is a work-in-progress implementation of /Magnolisp/, an experimental variant of the likewise experimental programming language [[http://magnolia-lang.org/][Magnolia]]. The current language is too small to be useful for implementing anything other than non-termination, but the current focus is to keep the language fairly small and manageable while trying out different designs for the implementation internals.

The motivation for this tool is to serve as a platform for trying out what Magnolia features could be implemented as macros, and more generally to explore /domain engineering/ of language implementations. The language itself follows the spirit of Magnolia, while making whatever concessions are useful in the interests of pragmatism.

The implementation has both an evaluator (implemented in the usual way as a [[http://racket-lang.org/][Racket]] =#lang=) and a source-to-source compiler targeting C++. The motivation for an evaluator is to act as a fast testing facility, a simulator of sorts, whereas for deployment on interesting platforms C++ source code is required. Initially the macro programming language is Racket, but as Magnolisp gets more capable, we might instead or additionally support syntax transformers written in Magnolisp; there is an evaluator for it, after all.

Initially we shall see where we can get by leveraging the Racket facilities as much as possible. We can work on addressing the limitations once we understand them. We are currently using the Racket macros system directly, for example, and this may seem somewhat kludgey. It is particularly unclear at present as to how to implement module support for runtime code; =require= and =provide= of runtime code currently only works for the evaluator, yet the compiler is supposed to support the same language. We do want to output a single, full-program optimized C++ implementation file, but it would nonetheless be highly useful to be able to organize the source code as modules.

If we cannot achieve a satisfactory design based on Racket facilities, perhaps due to Racket lacking the necessary flexibility, then we can implement our own macro and module support, perhaps drawing on the models described in the Macros That Work Together and Composable and Compilable Macros papers. Even afterwards we will want to retain the possibility of implementing primitives in Racket for the evaluator through an "FFI", as Racket is the evaluator's runtime environment; the use of the Racket macro and module systems would then be confined to primitive implementation. The primitives could naturally be invoked from Magnolisp-based syntax transformers as well.
