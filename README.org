This is a work-in-progress implementation of /Magnolisp/, an experimental variant of the likewise experimental programming language [[http://magnolia-lang.org/][Magnolia]]. The current language is too small for implementing anything useful. More language needs adding, but the idea is to keep the language fairly small and manageable while trying out different designs for the implementation internals. Magnolisp's component-level language shall come from Magnolia, algebraic language can include anything "C++ symbiotic" (i.e., anything naturally and efficiently mappable to C++), and at least initially Racket is used as the macro language. Language design concessions shall favor pragmatism instead of ideological or mathematical purity.

This tool shall serve as a platform for trying out what Magnolia features can be implemented as macros, and more generally for exploring /domain engineering/ of language implementations. The motivation for this is to keep the language adaptable when writing applications for heterogeneous devices.

The implementation has both an evaluator (implemented in the usual way as a [[http://racket-lang.org/][Racket]] =#lang=) and a source-to-source compiler targeting C++. The motivation for an evaluator is to act as a fast testing facility, a simulator of sorts, whereas for deployment onto interesting platforms C++ source code is required. Currently the macro programming language is Racket, but as Magnolisp gets more capable, we might instead or additionally support syntax transformers written in Magnolisp; there is an evaluator for it, after all.

Initially we shall see where we can get by leveraging the Racket facilities as much as possible. We can work on addressing the limitations once we understand them. We are currently using the Racket macro system directly, and this may seem somewhat kludgey, as everything must be encoded in terms or Racket abstract syntax. It is particularly unclear at present as to how to implement module support for runtime code; =require= and =provide= of runtime code currently only works for the evaluator, yet the compiler is supposed to support the same language. Could we somehow externally override the definition of =magnolisp= for compiled code, and get access to fully expanded syntax for all modules in a program? We do want to output a single, full-program optimized C++ implementation file, but it would nonetheless be highly useful to be able to organize the source code as modules.

If we cannot achieve a satisfactory design based on Racket facilities, perhaps due to Racket lacking the necessary flexibility, then we can implement our own macro and module support, perhaps drawing on the models described in the Macros That Work Together and Composable and Compilable Macros papers. Even afterwards we will want to retain the possibility of implementing primitives in Racket for the evaluator through an "FFI", as Racket is the evaluator's runtime environment; the use of the Racket macro and module systems would then be confined to primitive implementation. The primitives could naturally be invoked from Magnolisp-based syntax transformers as well.

* Running

  Programs written in =#lang magnolisp= can be evaluated in the usual Racket way. The compiler has no proper API yet, but can be invoked by evaluating =compiler.rkt=, specifying the program to compile. Depends on =uncrustify= as an external tool, and the tool requires a configuration file; one is installable using the provided =Makefile=.

* License

  Except where otherwise noted, all code is authored by Tero Hasu, copyright University of Bergen, and not licensed for distribution at this time.
